# 常用算法小结

### 排序 , 检索

```js
/**
 * 
 *
    基本算法总结

    一: 排序
    - 冒泡: 从一边向另一边一次对比,含有交换,把最大值或者最小值最终移动到一端
    - 选择: 从一边剩余的数中找出最大或最小值移动到另一端,不含交换
    - 插入: 从剩余的元素中依次放到已经排行序的一端,并找到正确的位子插入
    - 希尔: 有间隔的插入排序,间隔依次减小最终实现排序
    - 归并:把数组分割成细小的粒度,相邻直接两两对比并排序 ====> 把一系列子序列合并成大的完整有序序列
    - 快速:用基准值,较大的和较小的放到不同的数组中,再递归
   二: 检索 
    - 顺序查找: 顺序暴力查找
    - 二分查找: 不停折中找中间值进行比较(前提序列是有序的)
    - 高级算法
      + 动态规划: 和递归相反,它是从底部分解很多小问题解决 ,组合解决方案
      + 贪心算法: 找最优解
 * 
 * 
 * 
 */

// 冒泡
// 特点:双循环,外循环占位子,内循环比较找目标值
function bubbleSort() {
  let arr = [3, 4, 9, 2, 33, 34, 89, 5, 29];

  for (let out = arr.length; out >= 2; out--) {
    for (let inner = 0; inner < out - 1; inner++) {
      if (arr[inner] > arr[inner + 1]) {
        // 交换
        swrap(arr, inner, inner + 1);
      }
    }
  }
}
// bubbleSort();
// 选择

function selectSort() {
  let arr = [3, 4, 9, 2, 33, 34, 89, 5, 29];
  let length = arr.length;
  let maxIdx;
  for (let out = length - 1; out >= 1; --out) {
    maxIdx = out;
    for (let inner = 0; inner <= out - 1; inner++) {
      if (arr[inner] > arr[maxIdx]) {
        maxIdx = inner;
      }
    }

    // arr[out] = max;
    swrap(arr, maxIdx, out);
  }

  //   let minIdx;

  //   for (let out = 0; out <= lenght - 2; out++) {
  //     minIdx = out;
  //     for (let inner = out + 1; inner <= lenght - 1; inner++) {
  //       if (arr[inner] < arr[minIdx]) {
  //         minIdx = inner;
  //       }
  //     }
  //     swrap(arr, minIdx, out);
  //   }

  return arr;
}

function insertSort() {
  let arr = [3, 4, 9, 2, 33, 34, 89, 5, 29];
  let len = arr.length;

  let inner, temp;
  for (let i = 1; i < len; i++) {
    inner = i;
    temp = arr[i];

    while (inner > 0 && arr[inner - 1] > temp) {
      arr[inner] = arr[inner - 1];
      inner--;
    }
    arr[inner] = temp;
  }
  return arr;
}
// console.log('插入结果排序:', insertSort());
// 希尔
function shell() {
  let arr = [3, 4, 9, 2, 33, 34, 89, 5, 29];
  let len = arr.length;
  let gaps = [5, 3, 1];
  for (var g = 0; g < gaps.length; g++) {
    let gap = gaps[g]; // gap(=5)

    for (var i = gap; i < len; i++) {
      // i(=5,<length)
      var temp = arr[i];

      for (
        var j = i;
        j >= gap && arr[j - gap] >= temp; // j(=5,>)
        j -= gap
      ) {
        // arr[j] = arr[j - gap];
        swrap(arr, j, j - gap);
      }

      //   arr[j] = temp;
    }

    console.log('调换后', arr);
  }


  console.log('完成后的序列', arr);
}
// shell();

function dynamicSort() {
  let arr = [3, 4, 9, 2, 33, 34, 89, 5, 29];
  let N = arr.length;
  let h = 1;
  while (h < N / 3) {
    h = h * 3 + 1;
  }

  while (h >= 1) {
    for (let i = h; i < N; i++) {
      for (let j = i; j > h && arr[j - h] > arr[j]; j -= h) {
        swrap(arr, j, j - h);
      }
    }
    h = (h - 1) / 3;
  }

  console.log(arr);
}
// dynamicSort();

function mergeSort() {
  let arr = [3, 4, 9, 2, 33, 34, 89, 5, 29];

  let step = 1,
    left,
    right;
  while (step < arr.length) {
    left = 0;
    right = step;
    while (right + step <= arr.length) {
      mergeArrays(arr, left, left + step, right, right + step);
      left = right + step;
      right = left + step;
    }
    if (right < arr.length) {
      mergeArrays(arr, left, left + step, right, arr.length);
    }
    step *= 2;
  }

  return arr;
}

function mergeArrays(arr, startLeft, stopLeft, startRight, stopRight) {
  var right = new Array(stopRight - startRight + 1);
  var left = new Array(stopLeft - startLeft + 1);

  var k = startRight;
  for (let i = 0; i < right.length - 1; i++) {
    right[i] = arr[k];
    ++k;
  }

  k = startLeft;
  for (let i = 0; i < left.length - 1; i++) {
    left[i] = arr[k];
    ++k;
  }

  left[left.length - 1] = Infinity;
  right[right.length - 1] = Infinity;

  var m = 0,
    n = 0;

  for (var k = startLeft; k < stopRight; k++) {
    if (left[m] <= right[n]) {
      arr[k] = left[m++];
    } else {
      arr[k] = right[n++];
    }
  }
}

function quickSort() {
  let arr = [3, 4, 9, 2, 33, 34, 89, 5, 29];
  return quickFunc(arr);
}
function quickFunc(arr) {
  if (arr.length === 0) return [];
  let left = [],
    right = [];

  let temp = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < temp) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }

  return quickFunc(left).concat(temp, quickFunc(right));
}
console.log('快排的结果', quickSort());

function swrap(arr, i1, i2) {
  let temp = arr[i1];

  arr[i1] = arr[i2];
  arr[i2] = temp;
}

//////// find====================

function find() {}
function seqSearch(arr, data) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] == data) return i;
  }
  return -1;
}
function findMax() {
  var max = arr[0];
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] > max) {
      max = i;
    }
  }
}

// 自组织数据 8 2 原则

function serchCustomsetting(arr, data) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === data && i > arr.length * 0.2) {
      swrap(arr, i, i - 1);
    }
  }
  return -1;
}
// 二分查找

function bindSearch(arr, data) {
  var upper = arr.length - 1;
  var lower = 0;
  while (lower < upper) {
    var mid = Math.floor((upper + lower) / 2);
    if (arr[mid] < data) {
      lower = mid + 1;
    } else if (arr[mid] > data) {
      upper = mid - 1;
    } else {
      return mid;
    }
  }
  return -1;
}

// 高级算法
// 动态规划 , 贪心算法

// fib 递归实现
function recurFib(n) {
  if (n < 2) return n;
  return recurFib(n - 1) + recurFib(n - 2);
}

// fib 动态规划

function dynFib(n) {
  var val = [];
  for (var i = 0; i <= n; i++) {
    val[i] = 0;
  }
  if (n == 0) {
    return 0;
  } else if (n == 1 || n == 2) {
    return 1;
  } else {
    val[1] = 1;
    val[2] = 1;
    for (var i = 3; i <= n; i++) {
      val[i] = val[i - 1] + val[i - 2];
    }
    return val[n];
  }
}

// fib no arr

function iterFib(n) {
  if (n > 0) {
    var last = 1;
    var nestLast = 1;
    var result = 1;
    for (var i = 2; i <= n; i++) {
      result = last + nestLast;
      nestLast = last;
      last = result;
    }
    return result;
  } else {
    return 0;
  }
}


```