### js基础知识点的补充
 基于第一周作业讲解的补充，主要内容是变量提升，gc,词法作用域
### 1. 变量提升
> 变量提升是指对一个变量的**使用 先于 定义**,提升的规则基于词法作用域，尤其对函数的提升是对词法作用域很好的体现。
- 普通变量提升
```
    console.log(a); // undefined
    {
        var a=1
    }
 
    //相当于
 
    var a;
    console.log(a);
    {
        a=1
    }
```
- 函数的提升
```
    console.log(f);

    {
        function f(){}
    }

    // 相当于

    var f;
    console.log(f);
    {
        f=function(){}
    }


```

### 2. 词法作用域
在词法作用域中不得不说的是块级作用域，块级作用域对产生暂时性死区（TDZ）,TDZ会把里面的函数存起来（类似于表达式式的把函数存给一个变量），阻止作用域外部修改 
- 举例说明
```
    // 不在块级作用域下，函数名可以被修改
    function f(a){
        f=a;
    }
    f(1);
    // f ----> 1;

    // 在块级作用域下，函数名不可以被修改

    {
        function f(a){
            f=a;
        }
    }

    f(1);
    typeof f // 'function'

    // 在块级作用域内部修改，并打印，来证实函数是在块级作用域中会生成一个  f变量，但是在挂在该块级作用域上的函数f不会被改
    {
        function f(a){
            f=a;
        }
        f(1);
        console.log(f) ;// 1
        f(2); // f is not a function
    }
    // 块中表面上改变了f，但不影响在块外对 f函数的正常使用
    f(2)
    typeof f // 'function'

```
### 3. gc 
- 当你把一个变量置空后，gc并不立马执行回收
- eval 不会对所有词法作用域上的变量进行解绑
- new Function()中参数如果被引号包裹，则当前的作用域为全局作用域；相反则指当前所在的作用域；
- with,catch都会影响gc，浏览器遇到with会放弃当前所有变量的回收，catch 延长当前作用域链，也不会被回收