## 函数式编程简单代码实现

这部分内容是对函数式编程代码实现的总结,从 基础的container 到 IO 的一步步实现及其各自区别,这部分理论的内容已经做过总结,代码实现相对很简单,那么在此就直接上代码了:

```js
var Container = function (x) {
  this.__value = x;
};

Container.of = (x) => new Container(x);

Container.prototype.map = function (f) {
  return Container.of(f(this.__value));
};

let ins = Container.of(9);

let ins2 = ins.map((a) => a * 10);

// console.log(ins);
// console.log(ins2);

// let add = (x, y) => x + y;
// add(1)(2)(3)

function cAdd(...args) {
  let r = function (...args2) {
    let composeArgs = [...args, ...args2];

    return composeArgs.reduce((x, y) => x + y);
  };
  r.valueOf = function (...rargs) {
    return args.reduce((x, y) => x + y);
  };
  r.toString = function (...rargs) {
    return args.reduce((x, y) => x + y);
  };
  return r;
}

// let r = cAdd(1, 2, 3);
// console.log('result', r);

// 函子
let Functor = function (x) {
  Container.call(this, x);
};
Functor.prototype = Object.create(Container.prototype);
Functor.prototype.constructor = Functor;

let Monad = function (x) {
  Functor.call(this, x);
};
Monad.prototype = Object.create(Functor.prototype);
Monad.prototype.constructor = Monad;
Monad.prototype.join = function () {
  return this.__value;
};
Monad.prototype.flatMap = function (f) {
  return this.map(f).join();
};

// IO 脏处理
let compose = (a, b) => a(b); // 简单般,没有处理异常
let IO = function (f) {
  Monad.call(this, f);
};
IO.of = (x) => new IO(x);
IO.prototype = Object.create(Monad.prototype);
IO.prototype.constructor = IO;
IO.prototype.map = function (f) {
  return IO.of(compose(f, this.__value));
};

let fs = require('fs');
let readFile = function (filepath) {
  return new IO(function () {
    return fs.readFileSync(filepath, 'utf-8');
  });
};

let print = function (x) {
  console.log('print');
  return IO.of(function () {
    console.log('print--IO.of');
    return x + '函数式';
  });
};
let tail = function (x) {
  console.log('tail');
  return IO.of(function () {
    console.log('tail--IO.of');
    return x + '函数式-tail';
  });
};

let result = readFile('./uer.txt').flatMap(print)().flatMap(tail)();

console.log(result.__value());


```