# 前端中的数据结构和算法

### js的内存堆和栈
- 栈区(stack):由编译器自动分配释放，存放函数的参数值，局部变量，其操作方式类似数据结构的堆
- 堆区(heap)：一般由程序员手动分配释放，若程序员不释放的话，程序结束时可能由OS回收，值得注意的是它和数据结构中的堆是两回事，分配方式类似于数据结构中的链表
- 全局区(static):也叫静态数据内存空间，存储全局变量和静态变量，全局变量和静态变量的存储是放在一起的；初始化的全局变量和静态变量一块区域；没有初始化的在相邻的另一块区域；程序结束后由系统释放
- 文字常量区：常量字符串就是放在这里；程序结束由系统释放
- 程序代码区：存放函数体的二进制代码
- buffer： 直接向C申请，不用堆栈参与管理

### js的执行过程

1. 先理清几个基本知识点及概念

- 闭包，保留了自己的词法作用域就是闭包，其中词法作用域是指私有空间
- 由于JS的入口也是一个函数，js的一切操作都在该块内，所有js的所有函数都是闭包

- 执行中 ECS ：Excution context stack
- 每个函数都会创建一个 EC
- 每个函数执行时都会讲自己塞到 ESC 中

2. 几个重要变量

- GC：global context，外部创建一个匿名函数的目的就是将全局的变量存到 GC中，并讲GC推到ECS的栈底，用不出栈，所以全局变量不能被回收

- VO   variable object，链接ECS里的每一个函数
- AO   activation object
- GO   global Object
- 几个对象的关系
```
    VO(gc) = GO
    VO(test)=AO

    function test(){}

    // 代码说明帮助

    var a=10;
    function test(x){
        var b=20
    }
    test(30)

    VO(gc)={
        a:10,
        test:<func>
    } = GO

    VO(test)={
        x:30,
        b:20
    }

    // test在执行时，创建了arguments
    VO(test)=AO(test)={
        arguments,
        x:30,
        b:20
    }



    //js有变量提升阶段，AO在此阶段发挥作用，定义阶段
    AO(test)={
        b:undefined,
        this:undefined
    }
    //赋值阶段
    AO(test)={
        b:10
    }

```
- 创建函数的过程
```
    test(EC)={
        scopeChain:scopes,
        AO:{
            b:10,
            arguments
        },
        VO:{},
        scopes:[AO,VO,GO]//其中 VO为上层函数的VO
        this：运行时确定 // 实际上它指向ESC的栈顶
    }


```

3. 代码分析

```
    function test(){
        var result=[];
        for(var i=0;i<10;i++){
            result[i]=function(){
                return i;
            }
        }
        return result;
    }

    知识点：
        1.函数test执行完出栈，留下整个AO(test)i的指向到堆里
        2.执行对应的闭包，再回ECS里去
        3.AO(result[i])--->AO(test)--->GO
```
