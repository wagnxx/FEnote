## 面向对象和继承相关的知识点

这部分内容也比较简单,直接上小例

```js

/**
    通常情况创建不可变类的时候直接使用 属性描述符 和 Object.create,导致代码
    可读性很差,
    这个时候需要对其进行封装,
    即 属性描述符工具函数

*/

/**
 * 
 * @param {object} o 
    @description 将o的指定名字或者所有的属性设置为不可写,不可配置的
 */
function freezeProps(o) {
  var props =
    arguments.length == 1
      ? Object.getOwnPropertyNames(o)
      : Array.prototype.splice(arguments, 1);
  props.forEach(function (n) {
    if (!Object.getOwnPropertyDescriptor(o, n).configurable) return;
    Object.defineProperty(o, n, { writable: false, configurable: false });
  });
  return o;
}

/**
 * 将 o 的指定属性或者所有属性设置为不可枚举的和可配置的
 * @param {object} o
 */
function hideProps(o) {
  var props =
    arguments.length == 1
      ? Object.getOwnPropertyNames(o)
      : Array.prototype.splice(arguments, 1);
  props.forEach(function (n) {
    if (!Object.getOwnPropertyDescriptor(o, n).configurable) return;
    Object.defineProperty(o, n, { enumerable: false });
  });
  return o;
}

// 实现一个简单不可变类
function Range(from, to) {
  this.from = from;
  this.to = to;
  freezeProps(this);
}
Range.prototype = hideProps({
  constructor: Range,
  includes: function (x) {
    return this.from < x && x < this.to;
  },
  foreach: function (f) {
    for (var x = Math.ceil(this.from); x < this.to; x++) f(x);
  },
  toString: function () {
    return '(' + this.from + '...' + this.to + ')';
  },
});

// 面向对象
// 特点:
// 封装(低耦合高内聚),多态(包含重载和重写),继承

// 继承:原型链,call和寄生组合,es6的继承

// A 父类,B 子类

// ================================= 原型链继承 ==============================
/**
 * 让父类中的属性和方法在子类实例的原型链上
 * @param {*} x
 */
function A(x) {
  this.x = x;
}

A.prototype.getX = function () {
  console.log(this.x);
};

function B(y) {
  this.y = y;
}
// 核心就这两步
// B的原型指向A的实例,才有就会通向A的原型
// B.prototype的constructor要指回自己
B.prototype = new A(200);
B.prototype.constructor = B;
B.prototype.getY = function () {
  console.log(this.y);
};
let b = new B(100);
b.getY();
b.getX();

// ================================= 原型链继承 END ==============================

// call 继承

// ================================= call继承 ==============================

/**
 * 
 * @param {*} x 
  call 继承的特点:
    1. 子类构造函数中调用 父类,将父类非方法当普通函数执行
        让父类的this指向子类实例,相当于给子类实例设置了父类的
        属性和方法
     2. 只能继承父类私有的属性和方法,(因为把父类当普通函数执行,父类的原型不生效)
     3. 结果:父类私有的变为子类私有的,还差 父类共有的变子类共有!

 */
function A(x) {
  this.x = x;
}
A.prototype.getX = function () {
  console.log(this.x);
};

function B(y) {
  A.call(this, 200);
  this.y = y;
}

B.prototype.getY = function () {
  console.log(this.y);
};

// ================================= call继承 END ==============================

// 寄生组合
// ================================= 寄生组合  ==============================
/**
 * 寄生组合继承:
        call继承 + 类似原型继承
        特点:
            父类私有和共有的分别是子类实例的私有和共有属性方法
 * @param {*} x 

 */
function A(x) {
  this.x = x;
}
A.prototype.getX = function () {
  console.log(this.x);
};

function B(y) {
  A.call(this, 200);
  this.y = y;
}

B.prototype = Object.create(A.prototype);
B.prototype.constructor = B;
B.prototype.getY = function () {
  console.log(this.y);
};

// ================================= 寄生组合 END ==============================
// es6 继承
// ================================= ES6   ==============================

/**
 * es6创建的类不能当做普通函数执行
 */
class A {
  constructor(x) {
    this.x = x;
  }
  getX() {
    console.log(this.x);
  }
}

class B extends A {
  constructor(y) {
    super(200);
    this.y = y;
  }
  getY() {
    console.log(this.y);
  }
}

// ================================= ES6  END ==============================

// Object.create method
// ================================= Object.create method ==============================
Object.create = function (obj) {
  // let oo = {};
  // oo.__poto__=obj;
  // return oo;
  function F() {}
  F.prototype = obj;
  var f = new F();
  return f;
};
// ================================= Object.create method END ==============================






```